const FormData = require("form-data");
const { MAIN_KEYS } = require("./geminikey.js");
require("dotenv").config();

const MW_API = process.env.MW_API;
const USERNAME = process.env.BOTUSERNAME;
const PASSWORD = process.env.BOTPASSWORD;

// -------------------- DYNAMIC IMPORT FOR GEMINI CLIENT --------------------
let GoogleGenAI;
async function getGeminiClient(apiKey) {
  if (!GoogleGenAI) {
    const mod = await import('@google/genai');
    GoogleGenAI = mod.GoogleGenAI;
  }
  return new GoogleGenAI({ apiKey });
}

// -------------------- MULTI-KEY HANDLING FOR GEMINI --------------------
async function runWithMainKeys(fn) {
  const keysArray = Array.isArray(MAIN_KEYS) ? MAIN_KEYS : [MAIN_KEYS];
  if (keysArray.length === 0) throw new Error('No Gemini keys provided');

  let lastErr;
  for (const key of keysArray) {
    try {
      const client = await getGeminiClient(key);
      return await fn(client);
    } catch (err) {
      const msg = err?.message || err.toString();
      console.error(`Gemini key ${key.slice(0,15)}‚Ä¶ failed:`, msg);
      // If rate-limit or service unavailable, try next key
      if (msg.includes('RESOURCE_EXHAUSTED') || msg.includes('429') || msg.includes('503')) {
        lastErr = err;
        continue;
      }
      throw err;
    }
  }
  throw lastErr || new Error('All Gemini keys failed');
}

 
// -------------------- MEDIAWIKI LOGIN (returns cookieHeader + csrfToken) --------------------

async function loginToWiki() {
    // === STEP 1: Get login token ===
    const tokenRes = await fetch(`${MW_API}?action=query&meta=tokens&type=login&format=json`);
    const tokenData = await tokenRes.json();
    const loginToken = tokenData?.query?.tokens?.logintoken;
    if (!loginToken) throw new Error("Failed to get login token");

    // collect cookies from step 1
    const initialCookies = [];
    tokenRes.headers.forEach((val, key) => {
        if (key.toLowerCase() === "set-cookie") initialCookies.push(val);
    });
    const initialCookieHeader = initialCookies.join("; ");

    // === STEP 2: Log in ===
    const formData = new URLSearchParams();
    formData.append("action", "login");
    formData.append("lgname", USERNAME);
    formData.append("lgpassword", PASSWORD);
    formData.append("lgtoken", loginToken);
    formData.append("format", "json");

    const loginRes = await fetch(MW_API, {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "Cookie": initialCookieHeader
        },
        body: formData
    });

    // collect *all* cookies after login
    const allCookies = [...initialCookies];
    loginRes.headers.forEach((val, key) => {
        if (key.toLowerCase() === "set-cookie") allCookies.push(val);
    });
    const cookieHeader = allCookies.join("; ");

    const loginData = await loginRes.json();
    if (loginData?.login?.result !== "Success") {
        console.error("Login failed:", loginData);
        throw new Error("Login failed: " + loginData?.login?.result);
    }

    console.log(`‚úÖ Logged in as ${USERNAME}`);
  
    // === STEP 3: Get CSRF token ===
    const csrfRes = await fetch(`${MW_API}?action=query&meta=tokens&type=csrf&format=json`, {
        headers: { Cookie: cookieHeader }
    });
    const csrfData = await csrfRes.json();
    const csrfToken = csrfData?.query?.tokens?.csrftoken;
    if (!csrfToken) throw new Error("Failed to get CSRF token");

    console.log("üîë Got CSRF token");

    return { cookieHeader, csrfToken };
}

// -------------------- GET FILE LIST --------------------
async function getFileList(cookieHeader) {
  const res = await fetch(`${MW_API}?action=query&list=allimages&ailimit=50&format=json`, {
    headers: { Cookie: cookieHeader }
  });
  const json = await res.json();
  if (!json?.query?.allimages) {
    console.warn('No images returned or unexpected format', json);
    return [];
  }
  return json.query.allimages.map(f => f.name);
}

// -------------------- DELETE FILE --------------------
async function deleteFile(fileName, csrfToken, cookieHeader) {
  const formData = new URLSearchParams();
  formData.append('action','delete');
  formData.append('title', `File:${fileName}`);
  formData.append('reason', 'Non-descriptive filename (auto-detected by Gemini)');
  formData.append('token', csrfToken);
  formData.append('format','json');

  const res = await fetch(MW_API, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      Cookie: cookieHeader
    },
    body: formData
  });
  const json = await res.json();
  if (json.error) {
    console.error('‚ö†Ô∏è Failed to delete', fileName, json.error.info);
  } else {
    console.log('üóëÔ∏è Deleted:', fileName);
  }
}

// -------------------- CHECK FILENAME USING GEMINI --------------------
async function isNonDescriptive(fileName) {
  return await runWithMainKeys(async (gemini) => {
    const prompt = `Is this filename non-descriptive or autogenerated? Only reply with "yes" if it's a generic, gibberish, or camera-style name like "Screenshot 2025-11-11.png" or "IMG_2345.jpg". Filename: ${fileName}`;

    const response = await gemini.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      maxOutputTokens: 50
    });

    // extract the text
    const text = response?.candidates?.[0]?.content?.parts?.[0]?.text?.toLowerCase() || '';
    return text.includes('yes');
  });
}

 
// -------------------- MAIN EXECUTION --------------------
(async () => {
  try {
    const { cookieHeader, csrfToken } = await loginToWiki();
    const files = await getFileList(cookieHeader);

    for (const file of files) {
      const bad = await isNonDescriptive(file);
      if (bad) {
        console.log('‚ùå Non-descriptive:', file);
        await deleteFile(file, csrfToken, cookieHeader);
      } else {
        console.log('‚úÖ Descriptive:', file);
      }
    }

    console.log('‚úÖ Finished processing all files');
  } catch (err) {
    console.error('Fatal error:', err);
  }
})();
